# Load our dotfiles like ~/.bash_prompt, etc.
#   ~/.extra can be used for settings you don't want to commit,
#   Use it to configure your PATH, thus it being first in line.
for file in ~/.{extra,exports,aliases,functions,secrets}; do
    [ -r "$file" ] && source "$file"
done
unset file

export LANG="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

[[ $- = *i* ]] && \
  { [ -r ~/.liquidprompt/liquidprompt ] && \
    source ~/.liquidprompt/liquidprompt; } || \
  { [ -r ~/liquidprompt/liquidprompt ] && \
    source ~/liquidprompt/liquidprompt;} ||
  { [ -r ~/.bash_prompt ] && source ~/.bash_prompt; }

# Add ~/bin:/usr/local/sbin:/usr/local/bin to path if they're not there
! echo $PATH |grep -Fq /usr/local/bin && \
  PATH=/usr/local/bin:$PATH
! echo $PATH |grep -Fq /usr/local/sbin && \
  PATH=/usr/local/sbin:$PATH

if hash brew 2>/dev/null; then
  # brew --prefix is slow
  #PATH=$(brew --prefix coreutils)/libexec/gnubin:$PATH
  ! echo $PATH |grep -Fq /usr/local/opt/coreutils/libexec/gnubin && \
    PATH=/usr/local/opt/coreutils/libexec/gnubin:$PATH
fi

# Set the default text editor.
export EDITOR='vi'
hash vim 2>/dev/null && export EDITOR='vim'
hash st 2>/dev/null && export TERMINAL='st'

[ $PS2 = "%_> " ] && export PS2="%_âš¡ "

# Set GOPATH environment variable to the Go lang workspace.
[ -d $HOME/Workspace/go-workspace ] && \
  export GOPATH=$HOME/Workspace/go-workspace

# Add the Go Workspace's bin subdirectory to PATH.
[ "${GOPATH}x" != "x" ] && \
  ! echo $PATH |grep -Fq $GOPATH/bin && \
  PATH=$PATH:$GOPATH/bin

! echo $PATH |grep -Fq $HOME/bin && \
  PATH=$HOME/bin:$PATH

[ -r $HOME/.LS_COLORS ] && [ ! -r $HOME/.dircolors ] && \
  ln -s $HOME/.LS_COLORS/LS_COLORS $HOME/.dircolors

[ -r $HOME/.dircolors ] && hash dircolors 2>/dev/null && \
  eval $(dircolors -b $HOME/.dircolors)

if [ -d ~/.nvm ]; then
  export NVM_DIR=~/.nvm

  # See https://github.com/creationix/nvm/issues/539#issuecomment-245791291
  # This loads nvm if installed via curl with directions from github
  [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh" --no-use
  # load from homebrew (without using brew --prefix nvm)
  [ -s "/usr/local/opt/nvm/nvm.sh" ] && . "/usr/local/opt/nvm/nvm.sh" --no-use

  alias node='unalias node ; unalias npm ; nvm use default ; node $@'
  alias npm='unalias node ; unalias npm ; nvm use default ; npm $@'
fi

# Syntax highlighting for less. Looking at the two common
# install paths should be slightly faster than using which
[ -r /usr/local/bin/src-hilite-lesspipe.sh ] && \
  export LESSOPEN="| /usr/local/bin/src-hilite-lesspipe.sh %s" && \
  export LESS=" -R "

[ -r /usr/bin/src-hilite-lesspipe.sh ] && \
  export LESSOPEN="| /usr/bin/src-hilite-lesspipe.sh %s" && \
  export LESS=" -R "

# Ubuntu
[ -r /usr/share/source-highlight/src-hilite-lesspipe.sh ] && \
  export LESSOPEN="| /usr/share/source-highlight/src-hilite-lesspipe.sh %s" && \
  export LESS=" -R "

# Check for GPG, and if installed, use it
# Based on https://gist.github.com/bmhatfield/cc21ec0a3a2df963bffa3c1f884b676b
user="${USER:-$(whoami)}"
if hash gpg-agent 2> /dev/null; then
  # We have gpg-agent, great
  export GPG_TTY=$(tty)
  if [ -z "$(pgrep -U $user gpg-agent)" ]; then
    eval $(gpg-agent --daemon --enable-ssh-support 2> /dev/null)
  fi
  if [ "${gnupg_SSH_AUTH_SOCK_by:-0}" -ne $$ ]; then
    export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
  fi
fi

if [ -z "$GPG_TTY" ] &&  hash ssh-agent 2> /dev/null; then
  # Fallback to SSH
  #
  # SSH agent stuff might need to be added. See
  # https://coderwall.com/p/qdwcpg/using-the-latest-ssh-from-homebrew-on-osx
  # for more details
  #
  # Use single ssh-agent launched by launchd
  #
  [ -f /usr/local/bin/ssh-ask-keychain ] && \
    export SSH_ASKPASS=/usr/local/bin/ssh-ask-keychain
  [ -f "/usr/lib/ssh/x11-ssh-askpass" ] && \
    export SSH_ASKPASS="/usr/lib/ssh/x11-ssh-askpass"

  # Discover the running ssh-agent
  export SSH_AGENT_PID=$(pgrep -U $user ssh-agent)

  # Found a running ssh agent? Link up to it. This is hard...
  if [ -n "$SSH_AGENT_PID" ]; then
    live_socket=0
    [ -r ${HOME}/.ssh-agent-info ] && \
      eval $(cat ${HOME}/.ssh-agent-info) > /dev/null && \
      ssh-add -l 2> /dev/null > /dev/null
    live_socket=$?;

    # if live_socket is non-zero, existing agent info file isn't valid and lsof doesn't work (anymore?)
    # Go find it manually
    [ $live_socket -ne 0 ] && \
      export SSH_AUTH_SOCK=$(ls -lt /tmp/ssh-*/agent.* 2> /dev/null | head -n 1 | grep $user | awk '{print $9}') && \
      ssh-add -l 2> /dev/null > /dev/null
    live_socket=$?

    # If live socket is still non-zero, we still don't have a live socket and our
    # cheater check didn't work. We'll go to ssh-find-agent, which is slow
    # but pretty thorough
    [ $live_socket -ne 0 ] && [ -r ${HOME}/.ssh-find-agent.sh ] && \
      source ${HOME}/.ssh-find-agent.sh && set_ssh_agent_socket
    live_socket=$?

    # If live socket is still non-zero, we need to just give up
    [ $live_socket -ne 0 ] && unset SSH_AGENT_PID && \
      echo "could not find socket for running agent. Install .ssh-find-agent.sh?"

    unset live_socket
  else
    # easy case - crank an agent up. It's still possible, though unlikely
    # we don't have ssh-agent. We'll save the socket info for later
    hash ssh-agent 2>/dev/null && \
      ssh-agent -s > ${HOME}/.ssh-agent-info && \
      eval $(cat ${HOME}/.ssh-agent-info) > /dev/null
  fi

  # Add all the local keys, getting the passphrase from keychain,
  # helped by the $SSH_ASKPASS script.
  [ -n "$SSH_AGENT_PID" ] && [ ! -z "$SSH_AUTH_SOCK" ] && \
    alias ssh='ssh-add -l > /dev/null || ssh-add && unalias ssh ; ssh'
fi # SSH section if gpg-agent not available

# Must be performed last
[ -r ${HOME}/.oh-my-bash-zsh/oh-my-bash-zsh.sh ] && \
  source ${HOME}/.oh-my-bash-zsh/oh-my-bash-zsh.sh
